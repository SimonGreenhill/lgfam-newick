---
title: Language classifications as standardized Newick phylogenetic trees with branch
  length
author: Dan Dediu (Dan.Dediu@mpi.nl), Max Planck Institute for Psycholinguistics,
  Nijmegen, The Netherlands
date: "23 October 2015"
output:
  pdf_document:
    fig_caption: yes
    number_sections: yes
  html_document:
    fig_caption: yes
    theme: readable
bibliography: family-trees-with-brlength.bib
---

<!--- load the required libraries -->
```{r, echo=FALSE, include=FALSE}
library(ape);
library(knitr);
source("../code/FamilyTrees.R");

do.expensive.computations = TRUE;
```

**Abstract:** One of the best-known types of non-independence between languages is represented by genetic relationships due to descent from a common ancestor.
While there are several classifications of languages into language families, each with its own advantages and disadvantages, they are relatively difficult to use by computational methods due to a lack of standardization.
Moreover, certain advanced methods (such as phylogenetics) require not only the topology of the language family tree but also information concerning the amount of evolution that has happened on the tree represented as the branch lengths, and this information is usually missing.
This paper presents a method that converts the language classifications provided by four widely-used databases ([Ethnologue](http://www.ethnologue.com/), [WALS](http://wals.info/), [AUTOTYP](http://www.autotyp.uzh.ch/) and [Glottolog](http://glottolog.org/)) into the *de facto* [Newick](http://evolution.genetics.washington.edu/phylip/newicktree.html) standard, aligns the four most used conventions of unique identifiers for linguistic entities (ISO 639-3, WALS, AUTOTYP and Glottocode), and adds branch length information form a variety of sources (the tree's own topology, an externally given numeric constant or a distance matrix).
The `R` scripts, input data and resulting Newick trees are provided in the [GitHub](https://github.com/ddediu/lgfam-newick) repository [https://github.com/ddediu/lgfam-newick](https://github.com/ddediu/lgfam-newick) in the hope that this will promote the use of advanced quantitative methods in answering questions concerning linguistic diversity and its temporal dynamics.


---

# Introduction <a name='Sec:Introduction'/>

Languages are not independent entities and the proper treatment of the various types of non-independence is crucial to drawing valid inferences [e.g., @ladd_correlational_2015; @roberts_linguistic_2013].
One of the best-known types of non-independence is due to shared ancestry [@campbell_language_2008]: the daughter languages tend to be more similar than expected due to the inheritance of characteristics from the mother language, similarity that tends to decrease with increasing temporal separation [this is also knwon as "Galton's problem" and applies more generally than linguistics; @mace_comparative_1994].
Such related languages descending from a common *proto-language* form a *language family*, the internal structure of which is usually represented as a tree.
In such a tree, the attested, present-day or recent, languages form the *leaves* (or *terminal nodes*) of the tree and the *internal nodes* represent extinct, mostly unattested, languages[^1].

Reliably identifying such *genetic relationships* is a complex problem [@campbell_language_2008; @bowern_routledge_2014] and many controversies exist, not only in what concerns the so-called "macro-families" but also in the composition and internal structure of more accepted language families.
For example, disagreements might exist in the actual set of languages belonging to the same family, in the internal relationships between these languages (the tree *topology*) and the amount of change (the *branch lengths*); see the [Figure](#Fig:language family trees) \ref{Fig:language family trees} below.

<!--- draw language trees -->
```{r, echo=FALSE, fig.cap="<a name='Fig:language family trees'/>\\label{Fig:language family trees}Three language families composed of the same four languages (*A*, *B*, *C* and *D*) but with different structures (left vs centre) and branch length (centre vs right). Time flows downwards from the proto-language at the top (*P3*, *P5* and *P5* respectively) towards the attested languages at the bottom. For example, in the leftmost tree languages *A* and *B* are more closely related than any is to language *C*. In the rightmost tree, language *B* has changed least since its most recent common ancestor (*P4*) with languages *A* and *B*."}
# Draw simple language trees:
trees <- list( read.tree(text="((A:1,B:1)P1:1,(C:1,D:1)P2:1)P3:1;"), read.tree(text="((A:1,B:1,C:1)P4:1,D:1)P5:1;"), read.tree(text="((A:0.5,B:0.2,C:0.4)P4:0.1,D:0.8)P5:1;") );
par(mfrow=c(1,length(trees)), mar=c(0,0,0,1)+0.1);
for( i in 1:length(trees) )
{
  plot(trees[[i]], ty="cladogram", show.node.label=TRUE, root.edge=FALSE, direction="downwards", srt=90, edge.color=grey(0.7), adj=0.5, no.margin=FALSE, cex=1);
}
```

There are three major difficulties facing modern quantitative methods that need to use such language classifications:

*  the existence of several such classifications,
*  the often non-standardized format these classifications are available in, and, 
*  specifically for methods (e.g., phylogenetic) that take into account not only the toplogy of the tree but also the amount of change, the general absence of branch length estimates.

This paper offers a solution to these issues by proposing a standardized representation of language family trees from several classifications using the *de facto* standard *Newick* tree format[^2], with added brach length estimates using multiple methods[^3].
Here I briefly describe the data sources, methods and output formats, while the accompanying [GitHub](https://github.com/ddediu/lgfam-newick) repository [https://github.com/ddediu/lgfam-newick](https://github.com/ddediu/lgfam-newick) contains the actual primary data (wherever possible given their respective licensing terms), the [`R`](https://www.r-project.org/) [@R2014] code and the resulting Newick language family trees with branch length.


# Data, methods and outputs <a name='Sec:Data, methods and outputs'/>

The language family topologies are given by the following four widely used language classifications: the [*Ethnologue*](http://www.ethnologue.com/) [denoted in the following as **E**; @lewis_ethnologue_2014; [http://www.ethnologue.com/](http://www.ethnologue.com/)], the [*World Atlas of Language Structures Online*](http://wals.info/) [WALS, **W**; @wals2013; [http://wals.info/](http://wals.info/)], [*AUTOTYP*](http://www.autotyp.uzh.ch/) [**A**; @Nicholsetal2013autotyp;[http://www.autotyp.uzh.ch/](http://www.autotyp.uzh.ch/)] and [*Glottolog*](http://glottolog.org/) [**G**; @glottolog2014; [http://glottolog.org/](http://glottolog.org/)].
For each of these resources, I downloaded the raw data containing the language classifications and converted them to Newick trees without branch length information (resulting thuse in pure tree *topologies*).


## Mapping between codes <a name='Sec:Mapping between codes'/>

However, before describing this transformation, it is important to discuss the issue of language *unique identifiers*.
Currently, there are several methods for allocating unique (and hopefully also persistent) identifiers to linguistic entities (most often existing or recently extinct languages, but also dialects or proto-languages) and the mapping between these systems is far from a simple problem.
Here, four standards are relevant: ISO 639-3 codes (tree letters, denoted in the follwing as **i**; http://www-01.sil.org/iso639-3), WALS codes (three letters, **w**; http://wals.info), AUTOTYP LIDs (numeric, **a**; http://www.autotyp.uzh.ch), and Glottocodes (alphanumeric: four letters followed by four digits, **g**; http://glottolog.org/glottolog/glottologinformation).
As a first step, I mapped these codes for all the linguistic entities present in the four databases, a process made possible by the fact that some of these also give other codes besides their primary one for the linguistic entities therein (see [Table](#Tab:mapping between codes) \ref{Tab:mapping between codes}) below.

            Database  Primary code   Other codes
-------------------- -------------- -------------
  Ethnologue (**E**)   **i**         --
        WALS (**W**)   **w**         **i** **g**
     AUTOTYP (**A**)   **a**         **i** **g**
   Glottolog (**G**)   **g**         **i**

Table: <a name='Tab:mapping between codes'/>\label{Tab:mapping between codes}Codes present in the databases; most databases also give other codes besides their primary code. Legend for codes: **i** = ISO 639-3, **w** = WALS, **a** = AUTOTYP LID, and **g** = Glottocode.

This mapping is in the TAB-separated file `./output/code_mappings_iso_wals_autotyp_glottolog.csv` which gives for each unique linguistic entity (the rows) the corresponding ISO 639-3 code (column "ISO"), WALS code (column "WALS"), AUTOTYP LID (column "AUTOTYP"), Glottocode (column "Glottolog"), the name as given by Ethnologue (column "Name.ethn"), by WALS (column "Name.wals"), by AUTOTYP (column "Name.autotyp") and by Glottolog (column "Name.glottolog"), the geographic coordinates (columns "Latitude" and "Longitude") in degrees as given by WALS and Glottolog[^4], and, in the last column ("UULID") the *Universally Unique Language IDentifier* in the format "[i--**i**][w--**w**][a--**a**][g--**g**]" explained in detail in Section \ref{Sec:The Newick trees and the naming convention} [The Newick trees and the naming convention](#Sec:The Newick trees and the naming convention).


## Building the tree topologies <a name='Sec:Building the tree topologies'/>

A second step is represented by the gathering of the raw data concerning the structure of the language families and exporting them as pure tree topologies in Newick format (without any branch length information).
Each database poses its own challanges as each tends to use particular representations of the genetic relationships between languages.
To standardize the process of topology extraction, conversion, exporting to and importing from file, I have written a collection of `R` [@R2014] types and functions (file `FamilyTrees.R`) which extend the *de facto* standard for representing phylogenetic trees in `R` as objects of class `phylo` [inmplemented in package `ape`; @ape2004].

The list below summarizies the format of the raw data and its acquisition:

*  **Ethnologue** [@lewis_ethnologue_2014] as opposed to the other three databases, the language classification data here is not provided in an easily downloadable form; instead, the Ethnologue website provides[^5] (as of February 2015) a webpage (http://www.ethnologue.com/browse/families) containing a list with all the language families and links to their respective webpages (e.g., http://www.ethnologue.com/subgroups/afro-asiatic).
  These family webpages were further downloaded and parsed in order to extract the tree structure of the family, as well as the group names and the language names and ISO 639-3 codes[^6];
*  **WALS Online** [@wals2013] provides the whole database (including language name, codes, geographic coordinates but also values for more than 130 typological features; http://wals.info/static/download/wals-language.csv.zip) under a Creative Commons Attribution-NonCommercial-NoDerivs 2.0 Germany (CC BY-NC-ND 2.0 DE; http://creativecommons.org/licenses/by-nc-nd/2.0/de/deed.en); here the important columns are WALS, ISO 639-3 and Glottolog codes, the languages' name, "genus" and "family", resulting in a rather flat three-levels structure; 
*  **AUTOTYP** [@Nicholsetal2013autotyp] the AUTOTYP trees are freely available for download (http://www.autotyp.uzh.ch/available.html), use and distribution provided that their source is clearly cited; the format of the language families is similar to the WALS in the sense that each language (row) contains the language names, the AUTOTYP LID, the Glottolog and the ISO 639-3 codes, as well as the "stock", "mbranch", "sbranch", "ssbranch" and "lsbranch" names, each denoting more and more superficial levels (i.e., the "stock" is the highest level corresponding to the language family), and in some cases intermediate levels might be missing;
*  **Glottolog** [@glottolog2014] as opposed to the other three databases, Glottlog provides the family trees already in a standardized Newick format (http://glottolog.org/static/trees/tree-glottolog-newick.txt) under a Creative Commons Attribution-ShareAlike 3.0 Unported License (CC BY-SA 3.0]; http://creativecommons.org/licenses/by-sa/3.0) license; here I only expanded the language codes with WALS and AUTOTYP.

The basic idea behind building the standardized tree topologies from these diverse formats[^7] is to maintain a forest of (partially) built language family trees to which a new full path from a proto-language to a language is added.
The algorithm first tries to identify an already present tree that contains the deeper part of the path (i.e., say adding "Indo-European $\rightarrow$ Germanic $\rightarrow$ North-West Germanic $\rightarrow$ English" would identify an already existing partial Indo-European tree) and, if so, adds the new (recent) part of the path to the tree.
In this manner, the forest of all language families in the database is iteratively built from the ground up ([Figure](#Fig:build forrest) \ref{Fig:build forrest}).

<!--- draw language trees -->
```{r, echo=FALSE, fig.cap="<a name='Fig:build forrest'/>\\label{Fig:build forrest}The leftmost partial family tree already exists in the forest when a new language *D* from subfamily *P1* in family *P2* (thus with full path *P2* $\\rightarrow$ *P1* $\\rightarrow$ *D*) is added, resulting in the rightmost tree."}
# Draw simple language trees:
trees <- list( read.tree(text="((A:1,B:1)P1:1,C:2)P2:1;"), read.tree(text="((A:1,B:1,D:1)P1:1,C:2)P2:1;") );
par(mfrow=c(1,length(trees)+1), mar=c(0,0,0,1)+0.1);
plot(trees[[1]], ty="cladogram", show.node.label=TRUE, root.edge=FALSE, direction="downwards", srt=90, edge.color=grey(0.7), adj=0.5, no.margin=FALSE, cex=1);
plot(0, 0, xlim=c(0,1), ylim=c(0,1), type="n", axes=FALSE);
segments(0.5, 0.07, 0.5, 1.0, col=grey(0.7)); text( 0.5, 0.05, expression(italic("D")), cex=1.0); text( 0.5, 0.525, expression(italic("P1")), cex=1.0); text( 0.5, 1.0, expression(italic("P2")), cex=1.0);
text( 0.0, 0.525, "+", cex=2.0 ); text( 1.0, 0.525, "=", cex=2.0 ); 
plot(trees[[2]], ty="cladogram", show.node.label=TRUE, root.edge=FALSE, direction="downwards", srt=90, edge.color=grey(0.7), adj=0.5, no.margin=FALSE, cex=1);
```

[Table](#Tab:tree topologies) \ref{Tab:tree topologies} gives various summaries concerning the language family tree topologies successfully converted for each database.

<!--- summaries concerning the output -->
```{r, echo=FALSE, results='asis'}
get.summaries.trees <- function( classification, mcd )
{
  file.name <- paste( "../output/", classification, "/", classification, "-newick", mcd, ".csv", sep="" );
  if( do.expensive.computations && file.exists(file.name) )
  {   
    # read the trees:
    tmp <- read.table( file.name, header=TRUE, sep="\t", quote="" );
    # parse the trees:
    trees <- languageclassification( classification, csv.file=file.name );
    # count languages:
    no.lgs <- sapply( 1:length(trees), function(i){ count.languages( trees[[i]] ) } ); names(no.lgs) <- get.family.names(trees);
    # count depth:
    no.levels <- sapply( 1:length(trees), function(i){ count.levels( trees[[i]] ) } ); names(no.levels) <- get.family.names(trees);
    return (list("no.trees.success"=sum(tmp$Success == "SUCCESS"),
                 "no.trees.total"=nrow(tmp),
                 "no.lgs"=no.lgs,
                 "no.levels"=no.levels));
  } else
  {
    return (list("no.trees.success"=0,
                 "no.trees.total"=0,
                 "no.lgs"=0,
                 "no.levels"=0));
  }
}
summaries <- list("E"=get.summaries.trees( classification="ethnologue", mcd="" ),
                  "W"=get.summaries.trees( classification="wals"      , mcd="" ),
                  "A"=get.summaries.trees( classification="autotyp"   , mcd="" ),
                  "G"=get.summaries.trees( classification="glottolog" , mcd="" ));

cat("Table: <a name='Tab:tree topologies'/>\\label{Tab:tree topologies}Various summaries concerning the topologies (no branch length) of the language family trees extracted from the four databases; **E** = Ethnologue, **W** = WALS, **A** = AUTOTYP, and **G** = Glottolog; '#' stands for 'number of...'; '$\\mu$' is the 'average of...', '$m$' is the 'minimum of...' and '$M$' is the 'maximum of...'; 'lgs' stands for the leaves (or non-internal nodes) in the language family tree which are various types of lects (most often languages); 'lvl' represent the levels in the language family tree.");
kable(do.call(rbind, lapply(c("E","W","A","G"), function(classif)
                                                  {
                                                    data.frame("Classif"=paste0("**",classif,"**"),
                                                               "no.trees"=summaries[[classif]]$no.trees.total,
                                                               "no.leavles.tot"=sum(summaries[[classif]]$no.lgs,na.rm=TRUE),
                                                               "avg.leaves"=sprintf("%.1f",mean(summaries[[classif]]$no.lgs,na.rm=TRUE)),
                                                               "max.leaves"=max(summaries[[classif]]$no.lgs,na.rm=TRUE),
                                                               "min.levels"=min(summaries[[classif]]$no.levels,na.rm=TRUE),
                                                               "avg.levels"=sprintf("%.1f",mean(summaries[[classif]]$no.levels,na.rm=TRUE)),
                                                               "max.levels"=max(summaries[[classif]]$no.levels,na.rm=TRUE))
                                                  })),
      format="markdown", align=c("c","r","r","r","r","r","r","r"), col.names=c("**Class**", "**# trees**", "**# lgs**", "**$\\mu$ lgs**", "**$M$ lgs**", "**$m$ lvl**", "**$\\mu$ lvl**", "**$M$ lvl**"));
```



## The Newick trees and the naming convention <a name='Sec:The Newick trees and the naming convention'/>\label{Sec:The Newick trees and the naming convention}

An interesting question concerns the format in which these tree topologies (and later, branch lengths) should be exported.
I opted for the *de facto* standard Newick tree format[^8] widely used in evolutionary biology, read and exported by many software packages and libraries, and able to represent rooted and unrooted trees, with our without leaf and internal node names, and with or without branch lengths.
The basic idea is that subtrees are enclosed within parentheses "()" and the (optional) branch length is given as a number immediately following the branch and separated from it by ":".
For example, the leftmost tree in [Figure](#Fig:build forrest) \ref{Fig:build forrest} can be represented as (language = leaf, proto-languages or groups = internal nodes, for simplicity all branches have the same length of 1):

Representation                      Comments 
----------------------------------- -------------
((,),);                             just the structure
((*A*,*B*),*C*);                    with leaf names
((*A*,*B*)*P1*,*C*)*P2*;            with group names
((*A*:1,*B*:1),*C*:1);              with branch length
((*A*:1,*B*:1)*P1*:1,*C*:2)*P2*:1;  with everything

The language and group/proto-language names must include not only the actual name as given by the particular classification (which could very well differ between classifications; as a trivial example, Ethnologue calls the language with code ISO 639-3 "English" while Glottolog calls it "Standard English", but there are much more dramatic differences between the databases), but also the various unique identifiers this linguistic entity might have.
Therefore, I opted for a standardized node name that follows the convention:
$$\text{'NAME [i-I][w-W][a-A][g-G]'}$$
where CAPITAL LETTERS denote variables and the full node name is usually included within single quotes.
NAME is the entity name as given by the classification[^9], followed by a SPACE and the four unique codes I (ISO 639-3), W (WALS), A (AUTOTYP) and G (Glottocode), where each and all can be missing or can have multiple values (in which case the values are separated by "-").
A few examples are (from the WALS classification, the Indo-European family):

*  'German \{Zurich\} [i-gsw][w-gzu][a-1305-1306-1307-1308-1309-1310][g-swis1247]'
*  'Urdu [i-urd][w-urd][a-2671][g-urdu1245]'
*  'Romani \{Sepecides\} [i-][w-rse][a-][g-]'
*  'Germanic [i-][w-][a-][g-]'.


## The branch length methods <a name='Sec:The branch length methods'/>

The methods I used to add branch lengths to the tree topologies can be divided into:

(a) methods that depend only on the topology: (1) constant, (2) proportional and (3) grafen,
(b) methods that generate the branch length and topology from a distance matrix: (4) nj, and
(c) methods that map a given distance matrix onto the topology: (5) nnls and (6) ga.


<!--- The R code to illustrate these methods -->
```{r, echo=FALSE, results='hide'}
tree <- familytree( "((A,B)P1,C)P2;", "example" ); # a simple topology
d <- matrix( c( 0.0, 2.1, 3.9, 2.1, 0.0, 4.2, 3.9, 4.2, 0.0 ), ncol=3, byrow=TRUE ); # the distances matrix
tree.1  <- compute.brlen( tree, method="constant",     constant=1.0, distmatrix=NULL ); 
tree.2  <- compute.brlen( tree, method="proportional", constant=1.0, distmatrix=NULL ); 
tree.3  <- compute.brlen( tree, method="grafen",       constant=NA, distmatrix=NULL ); 
tree.4  <- compute.brlen( tree, method="nj",           constant=NA, distmatrix=d ); 
tree.5  <- compute.brlen( tree, method="nnls",         constant=NA, distmatrix=d ); 
tree.6a <- compute.brlen( tree, method="ga",           constant=NA, distmatrix=d ); 
tree.6b <- compute.brlen( tree, method="ga",           constant=NA, distmatrix=d ); 
tree.6c <- compute.brlen( tree, method="ga",           constant=NA, distmatrix=d ); 
```

The methods of type (a) only need a tree topology *T* (and possibly a numeric constant *k* > 0).
Method (1) computes branch lengths such that the sum of the branch lengths for every *root* $\rightarrow$ *leaf* path in the tree is equal to the constant *k*, meaning that the same amount of evolution *k* has happened on all branches.
For example, for the leftmost tree in [Figure](#Fig:build forrest) \ref{Fig:build forrest} and *k*=1.0, the resulting tree is
$$`r as.character(tree.1$tree)`$$
Method (2) simply gives each branch the same length *k* such that the amount of evolution on a path is proportional to the number of splits on that path; here the result is 
$$`r as.character(tree.2$tree)`$$
Method (3) is a reimplementation of @grafen_phylogenetic_1989 whereby first each node is given a "height" defined as the number of leaves of its subtree minus 1 (0 for the leaves), after which branch lengths are computed as the difference between the height of the lower and the upper nodes of the branch; our tree is then:
$$`r as.character(tree.3$tree)`$$

Method (4) is the only one of type (b) used here and is a clasic method in phylogenetics, the so-called "Neighbor-Joining" (or NJ) alorithm [@saitou_neighbor-joining_1987], essentially a clustering method that iteratively joins taxa into higher groupings (see http://en.wikipedia.org/wiki/Neighbor_joining for a good explanation).
Given a language family topology *T* and a distance matrix between a set of languages *D*, I extract the languages in *T* and the submatrix of distances between them *D~T~* (*NB*: it is possible that not for all pairs of languages there is a distance defined in *D*, resulting in a submatrix *D~T~* with missing data for those pairs of languages), and then use NJ [as implemented by `R`'s function `njs()` in package `ape`; @ape2004] to construct the corresponding phylogenetic tree.
Thus, this method does not consider the actual topology in *T* but only the set of languages and the distances between them.
For our example and the distance matrix (please note that the distances are given only between the languages -- the leaves -- and do not concern the proto-languages -- the internal nodes)
$$D = \begin{array}
{rrrr}
  &  A         &  B         &  C         \\
A & `r d[1,1]` & `r d[1,2]` & `r d[1,3]` \\
B & `r d[2,1]` & `r d[2,2]` & `r d[2,3]` \\
C & `r d[3,1]` & `r d[3,2]` & `r d[3,3]` \\
\end{array}
$$
which approximates the distances between the three languages in the right-most tree of [Figure](#Fig:build forrest) \ref{Fig:build forrest} assuming method (1) with *k* = 2.0, we have the NJ tree
$$`r as.character(tree.4$tree)`$$
It is important to note that NJ does not know anything about the internal structure of the original family tree (in this case about the *P1* internal node) and it might produce very different topologies from the ones given by the actual classifications.

Methods (5) and (6) try to use both the given language family's tree topology *T* and the information contained in the inter-language distance matrix *D* by computing branch lengths that best approximate the original distances in *D* (i.e., if one creates a new distance matrix between the languages *D'* by adding up the total branch lengths one needs to travel in the tree from one language to the other, then *D'* $\approx$ *D*).
Method (5) computes the branch lengths by using a non-negative least squares approach as implemented by `R`'s function `nnls.tree()` in package `phangorn` [@phangorn2011], resulting in this case in
$$`r as.character(tree.5$tree)`$$
Finally, method (6) estimates the branch lengths using a standard genetic algorithm as implemented by `R`'s function `ga()` in package `GA` [@GA2013].
Given a topology *T* with *n* branches, I need to compute *n* real positive numbers, each representing the length of a branch in *T* such that the resulting distance matrix *D'* is a good approximation of the original distances *D*.
In this genetic algorithm approach, I defined the "genome" as composed of *n* real-valued "genes", and the "fitness function" for a particular such genome *G* = (*g~1~*, *g~2~*, ..., *g~n~*) computes the SSE (sum of squared errors) between the original distances *D* and the current distances *D'* between languages if the topology *T* had the branch lengths *g~1~*, *g~2~*, ... *g~n~*.
The genetic algorithm finds the best solution *G^\*^* = (*g^\*^~1~*, *g^\*^~2~*, ..., *g^\*^~n~*) that minimizes the fitness function (the SSE) using a population size of 100 individuals for at most 10,000 iterations (or when the fitness does not change for 100 iterations).
For our example, some possible trees could be
$$`r as.character(tree.6a$tree)`$$
$$`r as.character(tree.6b$tree)`$$
$$`r as.character(tree.6c$tree)`$$
Please note that due to the random nature of the genetic algorithm and possibly the non-uniqueness of the solution (multiple optima), the best solution might vary between runs.
Methods (5) and (6) have similar goals and produce very similar results, but approach them in different ways; method (5) is less robust than method (6) (it fails for certain topologies and distance matrices), while method (6) is much slower, especially for very large trees, and might produce non-unique solutions.


## Topology preservation by restoring the collapsed single nodes <a name='Sec:Topology preservation'/>

Methods (5) and (6) use internally functions from the `ape` package that do not currently deal well with so-called "single nodes"; these are internal nodes that have a single descendant in the tree such as node *P1* in the mid (degenerated) tree in [Figure](#Fig:build forrest) \ref{Fig:build forrest}.
These functions require that the single nodes have been removed from the argument(s) prior to their call and, to this end, `ape` provides the function `collapse.singles()` that takes a single phylogeny of class `phylo` and returns it with the single nodes collapsed (i.e., these nodes are removed and their single child is directly connected to their parent).
Unfortunately, this means that for those language families that contain single nodes (which is the case quite often) the topology with branch length is not really the original topology anymore.

To address this problem, I extended the `collpase.nodes()` function to a pair of functions named  `collapse.singles.reversible()` and `reverse.collapse.singles()` that ensure that the single nodes are removed prior to applying functions that cannot deal with them but are correctly added back in afterwards so that the result fully reflects the original topology.
Briefly[^15], `collapse.singles.reversible()` behaves exactly as `collapse.singles()` but returns not only the tree without single nodes but also information on how to restore these collapsed nodes.
After the processing (in this context involving branch length computation), this information is used by `reverse.collapse.singles()` to insert back the removed single nodes into the tree, and the user can also specify how the new branch lengths are to be computed (keeping the original proportion, splitting the branch in two, or forcing the parent $\rightarrow$ single node branch to have length 0).
Thus, by using this pair of functions, we ensure that the resulting tree with brach length preserves the original topology faithfully.


## The distance matrices <a name='Sec:The distance matrices'/>

There are many potentially meaningful distances between languages, and while the framework and `R` code introduced here can accomodate new ones, I have used here the following:

a.  distances based on vocabulary: (1) ASJP16,
b.  distances based on geography: (2) great-circle,
c.  distances based on WALS: (3) gower and (4) euclidean, with and without missing data imputation,
d.  distance based on AUTOTYP: (5) gower with missing data using only the variables with a single datapoint per language (this distance was computed by Balthasar Bickel), and
e.  distances based on the tree topology: @maurits_tracing_2014's "genetic method" applied to the WALS (6), Ethnologue (7), Glottolog (8) and AUTOTYP (9) classifications.

```{r, echo=FALSE, results='hide'}
# The WALS data:
wals.data <- read.table( "../input/wals/language.csv", header=TRUE, sep=",", quote="\"", stringsAsFactors=FALSE ); # actual WALS data
wals.data <- wals.data[,grep("^X",names(wals.data))]; # keep only the features
```

```{r, echo=FALSE, results='hide'}
load( "../input/distances/ASJP/asjp16-dists.RData" ); # asjp16.dm
```
Method (1) uses the distances between languages provided by The Automated Similarity Judgment Program version 16 [ASJP16; @wichmann_asjp_2013] and the ASJP software (version 2.1), freely available under a Creative Commons Attribution 3.0 (CC BY 3.0, http://creativecommons.org/licenses/by/3.0) license from the authors' website (http://asjp.clld.org).
These distances are computed on the basis of standardized short wordlists transcribed in a reduced set of symbols using a normalized Levenstein distance [for details see @bakker_adding_2009].
I further processed and converted this database into a distance matrix between languages using ISO 639-3 codes as language identifiers[^10], resulting in a `r nrow(asjp16.dm)` $\times$ `r ncol(asjp16.dm)` matrix with no missing data.
```{r, echo=FALSE, results='hide'}
rm(asjp16.dm); # free up space
```

```{r, echo=FALSE, results='hide'}
load( file="../input/distances/geo-great-circle-ellipsoid-dists.RData" ); # geo.dm 
```
Method (2) computes the geographic (great circle) distances between the languages' geographic coordinates using `R`'s function `distm()` in package `geosphere` [@geosphere2014], resulting in a `r nrow(geo.dm)` $\times$ `r ncol(geo.dm)` matrix with no missing data.
```{r, echo=FALSE, results='hide'}
rm(geo.dm); # free up space
```

```{r, echo=FALSE, results='hide'}
load( "../input/distances/WALS/wals-gower-dm.RData" ); wals.gower.dm <- as.matrix(wals.gower.dm); # wals.gower.dm (with missing data)
load( "../input/distances/WALS/wals-gower-mode-dm.RData" ); wals.gower.mode.dm <- as.matrix(wals.gower.mode.dm); # wals.gower.mode.dm (with mode imputation for missing data)
load( "../input/distances/WALS/wals-euclidean-dm.RData" ); wals.euclidean.dm <- as.matrix(wals.euclidean.dm); # wals.euclidean.dm (with missing data)
load( "../input/distances/WALS/wals-euclidean-mode-dm.RData" ); wals.euclidean.mode.dm <- as.matrix(wals.euclidean.mode.dm); # wals.euclidean.mode.dm (with mode imputation for missing data)
```
Methods (3) and (4) use the WALS typological database to compute distances between languages using their feature values.
I used the methods implemented by `R`'s function `daisy()` in package `cluster` [@cluster2015], namely "gower" [method 3; @gower_general_1971] which standardizes each feature to the [0,1] interval, and "euclidean" (method 4) which computes the standard Euclidean distance in an *n*-dimensional real space.
Given the enormously high proportion of missing data in the WALS database (`r sprintf("%.1f",sum(wals.data == "")/(nrow(wals.data)*ncol(wals.data))*100)`% cells), I have computed these distances also doing a simple missing data imputation whereby the missing data was replaced by the mode (i.e., the most frequent value) of the corresponding typological variable.
With these, I obtained the follwing distance matrices: 
gower with missing data (`r nrow(wals.gower.dm)` $\times$ `r ncol(wals.gower.dm)`, `r sprintf("%.1f",sum(is.na(wals.gower.dm))/(nrow(wals.gower.dm)*ncol(wals.gower.dm))*100)`% missing data cells), 
gower with missing data imputation (`r nrow(wals.gower.mode.dm)` $\times$ `r ncol(wals.gower.mode.dm)`, no missing data), 
euclidean with missing data (`r nrow(wals.euclidean.dm)` $\times$ `r ncol(wals.euclidean.dm)`, `r sprintf("%.1f",sum(is.na(wals.euclidean.dm))/(nrow(wals.euclidean.dm)*ncol(wals.euclidean.dm))*100)`% missing data cells), 
and euclidean with missing data imputation (`r nrow(wals.euclidean.mode.dm)` $\times$ `r ncol(wals.euclidean.mode.dm)`, no missing data).
```{r, echo=FALSE, results='hide'}
rm(wals.gower.dm,wals.gower.mode.dm,wals.euclidean.dm,wals.euclidean.mode.dm); # free up space
```

```{r, echo=FALSE, results='hide'}
load("../input/distances/AUTOTYP/autotyp-dist.RData"); # autotyp.dm (with missing data, using ony features with single values per language, courtesy of Balthasar Bickel)
```
Method (5) uses the AUTOTYP typological database to compute distances between languages using their feature values.
This method also uses `R`'s function `daisy()` in package `cluster` [@cluster2015] with argument "gower" [@gower_general_1971], without missing data imputation, resulting in a `r nrow(autotyp.dm)` $\times$ `r ncol(autotyp.dm)` distance matrix with `r sprintf("%.1f",sum(is.na(autotyp.dm))/(nrow(autotyp.dm)*ncol(autotyp.dm))*100)`% missing data cells.
```{r, echo=FALSE, results='hide'}
rm(autotyp.dm); # free up space
```

```{r, echo=FALSE, results='hide'}
# The MG2015 [Maurits, L. & Griffiths, T.L. (2015) PNAS 111 (37):13576--13581] distances:
.change.row.col.names.to.codes <- function(m, code=c("iso","wals","autotyp","glottolog"))
{
  if( is.null(m) || !inherits(m,"matrix") || nrow(m) != ncol(m) || any(rownames(m) != colnames(m)) )
  { 
    stop("Problems with the distance matrix!\n"); 
    return (NULL); 
  } else
  {
    # Change the row and column names to the WALS codes:
    new.names <- vapply(rownames(m), function(s)
      { 
        tmp <- extract.name.and.codes(s); 
        if( is.null(tmp[[code]]) || length(tmp[[code]]) != 1 || tmp[[code]]=="" )
        { 
          warning(paste0("Language ",s," must have a single ", code, " code\n")); 
          return (s); 
        } else 
        {
          return(tmp[[code]]); 
        }
      }, character(1));
    return (new.names);
  }
}
load("../input/distances/MG2015/MG2015-wals-alpha=0.69.RData"); MG2015.WALS.nrow <- nrow(MG2015.WALS); MG2015.WALS.ncol <- ncol(MG2015.WALS); rm(MG2015.WALS);
load("../input/distances/MG2015/MG2015-ethnologue-alpha=0.69.RData"); MG2015.Ethnologue.nrow <- nrow(MG2015.Ethnologue); MG2015.Ethnologue.ncol <- ncol(MG2015.Ethnologue); rm(MG2015.Ethnologue);
load("../input/distances/MG2015/MG2015-glottolog-alpha=0.69.RData"); MG2015.Glottolog.nrow <- nrow(MG2015.Glottolog); MG2015.Glottolog.ncol <- ncol(MG2015.Glottolog); rm(MG2015.Glottolog);
load("../input/distances/MG2015/MG2015-autotyp-alpha=0.69.RData"); MG2015.AUTOTYP.nrow <- nrow(MG2015.AUTOTYP); MG2015.AUTOTYP.ncol <- ncol(MG2015.AUTOTYP); rm(MG2015.AUTOTYP);
```
Methods (6) -- (9) use the "genetic method" described in @maurits_tracing_2014 whereby branch lengths are computed from the topology of the family tree so that languages sharing *k* intermediate nodes on their paths from the root are separated by the distance *d* = *M* - $\sum_{i=1}^{n}{\alpha^{i}}$ (with *M* being the maximum possible distance and $\alpha$ being empirically fixed at 0.69); it is important to note that by defintion these distances cannot be computed for pairs of languages beloging to different families, but are defined for any pair of languages that belong to the same family (therefore the percent of missing data is uninformative here).
I reimplemented this method in `R`[^11] and applied it to each of the four classifications, resulting in the follwing distance matrices: 
MG2015 using the WALS classification (`r MG2015.WALS.nrow` $\times$ `r MG2015.WALS.ncol`),
the Ethnologue classification (`r MG2015.Ethnologue.nrow` $\times$ `r MG2015.Ethnologue.ncol`),
the Glottolog classification (`r MG2015.Glottolog.nrow` $\times$ `r MG2015.Glottolog.ncol`), and
the AUTOTYP classification (`r MG2015.AUTOTYP.nrow` $\times$ `r MG2015.AUTOTYP.ncol`).


## The family trees with branch length <a name='Sec:The family trees with branch length'/>

Thus, for each combination of *classification* (Ethnologue, WALS, AUTOTYP, Glottolog) by *method* (no branch length, constant, proportional, grafen, nj, nnls, ga) and, for the last three methods, also by *distance* matrix (asjp16, great-circle, wals-gower, wals-gower+imputation, wals-euclidean, wals-euclidean+imputation, autotyp-gower, mg2015+wals, mg2015+ethnologue, mg2015+glottolog, mg2015+autotyp[^16]), I produced a set of phylogenetic trees in Newick format as described above.
Each of these sets was saved in two formats: a TAB-separated CSV file, and a Nexus file, containing essentially the same information.

The first format is a standard TAB-separated CSV file with a standardized name of the form `CLASSIFICATION-newick-METHOD&PARAMETERS.csv` (e.g., `autotyp-newick-nj+autotyp.csv` and `glottolog-newick-nnls+wals(gower,mode).csv`) in the directory  `./output/CLASSIFICATION/`.
It contains the language families (one per row, except the first row which is the header), and for each family it gives the family name (as defined by the classification), the success or failure of the method, some relevant comments (for examply, why the methods has failed), and the actual tree in Newick format (or an empty string "" if the method has failed).

The second format is a standard Nexus file [@maddison_nexus_1997] with a standardized name of the form `CLASSIFICATION-nexus-METHOD\&PARAMETERS.nex` (e.g., `autotyp-nexus-nj+autotyp.nex` and `glottolog-nexus-nnls+wals(gower,mode).nex`) in the `./output/CLASSIFICATION/` directory.
These Nexus files contain only the `trees` block with the `translate` list[^12] and the named trees (the language family names as given by the classification) in Newick format.

Summaries about these trees are given in [Appendix A](#Appendix A).

<!--- Comparisons between methods -->
```{r, echo=FALSE, results='hide'}
tree.comparisons <- read.table( "../output/tree_comparisons_between_methods.csv", sep="\t", quote="", header=TRUE, stringsAsFactors=FALSE );
# Keep only those that were successfully computed:
tree.comparisons <- tree.comparisons[ !is.na(tree.comparisons$d.PH85) & !is.na(tree.comparisons$d.score) & tree.comparisons$d.PH85 >= 0 & tree.comparisons$d.score >= 0, ];
# To simply selection, replace NA by "":
tree.comparisons[ is.na(tree.comparisons) ] <- "";
# Summarize a pair of methods:
summaries.tree.comparisons <- function( classif="all", method1="all", const1="", dist1="", method2="all", const2="", dist2="" )
{
  if( classif == "all" && method1 == "all" && method2 == "all" )
  {
    s <- rep(TRUE, nrow(tree.comparisons));
  } else
  {
    if( classif == "all" )
    {
      s <- tree.comparisons$Method1 == method1 & 
            tree.comparisons$Constant1 == const1 & 
            tree.comparisons$Distance1 == dist1 &
            tree.comparisons$Method2 == method2 & 
            tree.comparisons$Constant2 == const2 & 
            tree.comparisons$Distance2 == dist2;
    } else
    {
      s <- tree.comparisons$Classification == classif & 
            tree.comparisons$Method1 == method1 & 
            tree.comparisons$Constant1 == const1 & 
            tree.comparisons$Distance1 == dist1 &
            tree.comparisons$Method2 == method2 & 
            tree.comparisons$Constant2 == const2 & 
            tree.comparisons$Distance2 == dist2;
    }    
  }
  
  if( sum(s,na.rm=TRUE) == 0 )
  {
    ret.val <- list("n"=0, 
                    "d.PH85"=list("min"="-",
                                  "max"="-",
                                  "mean"="-",
                                  "median"="-",
                                  "sd"="-",
                                  "values"=NULL),
                    "d.score"=list("min"="-",
                                  "max"="-",
                                  "mean"="-",
                                  "median"="-",
                                  "sd"="-",
                                  "values"=NULL) );
  } else
  {
    ret.val <- list("n"=sum(s,na.rm=TRUE), 
                    "d.PH85"=list("min"=sprintf("%.2f",min(tree.comparisons$d.PH85[s],na.rm=TRUE)),
                                  "max"=sprintf("%.2f",max(tree.comparisons$d.PH85[s],na.rm=TRUE)),
                                  "mean"=sprintf("%.2f",mean(tree.comparisons$d.PH85[s],na.rm=TRUE)),
                                  "median"=sprintf("%.2f",median(tree.comparisons$d.PH85[s],na.rm=TRUE)),
                                  "sd"=sprintf("%.2f",sd(tree.comparisons$d.PH85[s],na.rm=TRUE)),
                                  "values"=tree.comparisons$d.PH85[s]),
                    "d.score"=list("min"=sprintf("%.2f",min(tree.comparisons$d.score[s],na.rm=TRUE)),
                                  "max"=sprintf("%.2f",max(tree.comparisons$d.score[s],na.rm=TRUE)),
                                  "mean"=sprintf("%.2f",mean(tree.comparisons$d.score[s],na.rm=TRUE)),
                                  "median"=sprintf("%.2f",median(tree.comparisons$d.score[s],na.rm=TRUE)),
                                  "sd"=sprintf("%.2f",sd(tree.comparisons$d.score[s],na.rm=TRUE)),
                                  "values"=tree.comparisons$d.score[s]) );
  }
  
  return (ret.val);
}

overall.dists <- summaries.tree.comparisons();
```

To explore the (dis)agreement between the trees produced by these methods, for each language family (within a given classification as families do not generally mean the same thing across classifications) and pair of methods, I computed two distances[^13] between these corresponding trees: one that considers only how similar they are in their topology ["PH85"; @penny_use_1985; @rzhetsky_simple_1992] and another that also takes into account the branch length ["score"; @kuhner_simulation_1994].
For details please see [Appendix B](#Appendix B).


# Conclusions <a name='Sec:Conclusions'/>

This paper describes a flexible method for producing standardized language family trees in the Newick format with branch length using a variety of linguistic classifications, methods and distances between languages.
Accompanying this paper a [Github](https://github.com/ddediu/lgfam-newick) [https://github.com/ddediu/lgfam-newick](https://github.com/ddediu/lgfam-newick) repository containing (where possible given the licensing terms) the input data, the `R` code, the output files, and the source of this paper [written using [`R Markdown`](http://rmarkdown.rstudio.com/) @rmarkdown], as well as short descriptions (`ReadMe.txt` files) and license terms.
My own `R` code is released under a [GPL v2 license](http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html), is relatively well-commented and tested, and is free to use and modify as long as the terms of the license are respected and this paper is cited[^14].
Especially the high-level functions in `./code/FamilyTrees.R` might be useful for manipulating such trees and applying new distance matrices to family tree topologies; the file `./code/StandardizedTrees.R` can be consulted as an example of using them and it also contains some useful high-level functions.
Updates and bug fixes will be posted on the [Github](https://github.com/ddediu/lgfam-newick) <https://github.com/ddediu/lgfam-newick> repository.


# Acknowledgments <a name='Sec:Acknowledgments'/>

Many thanks to the authors of the databases used here for making their data freely available, to Balthasar Bickel for computing the AUTOTYP distance and agreeing to making it freely available with this paper, to Luke Maurits for clariying their "genetic method", and to Harald Hammarström and Seán Roberts for discussions and feedback.
During this project I was funded by an NWO (Netherlands Organisation for Scientific Research) VIDI grant number 016.124.315.



<!--- Footnotes -->
[^1]: Of course there are exceptions, such the inclusion of Latin -- a well-attested extinct language -- at the base of the Romance subfamily [e.g., @chang_ancestry-constrained_2015].
[^2]: This format is described in http://evolution.genetics.washington.edu/phylip/newicktree.html.
[^3]: Even if for a few large families (including *Indo-European*, *Austronesian*, *Bantu* and *Uto-Aztecan*, with this list continuously growing) high-quality posterior samples of trees with branch length derived from cognacy judgments on the basic vocabulary (and even with calibaration data) using Bayesian phylogenetic methods [e.g. @bouckaert_mapping_2012; @dunn_evolved_2011] are available, this is currently not the case for the vast majority of the families.
[^4]: When there is a discrepancecy greater than 1&deg; between the two, WALS wins.
[^5]: Under a set of conditions contained in the Terms of Use (www.ethnologue.com/terms-use) which allow "portions" of the data to be used for "research or educational purposes".
[^6]: The data used in this paper and included in the supplementary materials was harvested in Feburary 2015.
[^7]: Except for Glottolog, which provides a Newick format that requires only very light processing.
[^8]: See http://evolution.genetics.washington.edu/phylip/newicktree.html and http://en.wikipedia.org/wiki/Newick_format for details on the actual format.
[^9]: Given that some characters have a special meaning in the Newick format, I have enforced the following character substitutions: ,$\rightarrow$. '$\rightarrow$\` ($\rightarrow$\{ )$\rightarrow$\} TAB$\rightarrow$SPACE :$\rightarrow$| ;$\rightarrow$| and characters with diacritics into their plain form (e.g., á$\rightarrow$a and ã$\rightarrow$a) while leaving unaltered the other characters.
[^10]: This conversion required limited manual editing including the replacement of some non-ASCII characters in the language descriptors and some of the 26-character language identifiers exported by the ASJP v2.1 software.
[^11]: Many thanks to Luke Maurits for helping to clarify the inner workings of the method.
[^12]: The `R` script is capable of generating or not the `translate` list, by default it does so in order to increase human readablity and make the files importable by some phylogenetic software.
[^13]: As implemented by `R`'s function `dist.topo()` in package `ape` [@ape2004].
[^14]: Why not an `R` package, you migth ask? I feel this application is very specific and the code is mainly intended to be changed and adapted (or just serve as inspiration) for other specific problems the users might have, instead of being used as it is.
[^15]: For more details on this process please see my blog post [Tired of what ape’s collapse.singles() does?](https://bitsaying.wordpress.com/2015/09/22/tired-of-what-apes-collapse-singles-does-heres-a-way-to-put-those-nodes-back/) ([https://bitsaying.wordpress.com/2015/09/22/tired-of-what-apes-collapse-singles-does-heres-a-way-to-put-those-nodes-back/](https://bitsaying.wordpress.com/2015/09/22/tired-of-what-apes-collapse-singles-does-heres-a-way-to-put-those-nodes-back/)).
[^16]: Please note that given that MG2015 is computed using only the tree topologies, it makes little sense (as far as I can tell) to use the MG2015 computed on one classification for branch length computation on another classification; therefore only mg2015+wals was used for **W**, mg2015+ethnologue for **E**, mg2015+autotyp for **A**, and mg2015+glottolog for **G**.


# Appendix A: Family trees summaries <a name='Appendix A'/>\label{Appendix A}

This Appendix contains summaries concerning the language family trees generated using the classifications, methods and distances discussed in this paper, split into four Tables by classification used.

```{r, echo=FALSE, results='hide'}
# by classification
.table.by.classification <- function( classif="ethnologue" )
{
  # Get the summaries:
  mmapings <- c("asjp"="asjp16", 
                "geo"="geo", 
                "w:g"="wals(gower)", "w:e"="wals(euclidean)", "w:gm"="wals(gower,mode)", "w:em"="wals(euclidean,mode)", 
                "auto"="autotyp"); 
  if( classif == "ethnologue" ) mmapings <- c(mmapings, "m:e"="mg2015(ethnologue)");
  if( classif == "wals" ) mmapings <- c(mmapings, "m:w"="mg2015(wals)");
  if( classif == "autotyp" ) mmapings <- c(mmapings, "m:a"="mg2015(autotyp)");
  if( classif == "glottolog" ) mmapings <- c(mmapings, "m:g"="mg2015(glottolog)");
  summaries <- list(list("summaries"=get.summaries.trees( classification=classif, mcd="-constant=1.00" ), "method"="*const*", "parameter"="*k*=1.0"),
                    list("summaries"=get.summaries.trees( classification=classif, mcd="-proportional=1.00" ), "method"="*prop*", "parameter"="*k*=1.0"),
                    list("summaries"=get.summaries.trees( classification=classif, mcd="-grafen" ), "method"="*grafen*", "parameter"="-"));
  for( m in c("nj", "nnls", "ga") )
    for( i in 1:length(mmapings) )
      summaries[[length(summaries)+1]] <- list("summaries"=get.summaries.trees( classification=classif, mcd=paste0("-",m,"+",mmapings[i]) ), 
                                               "method"=paste0("*",m,"*"), 
                                               "parameter"=paste0("*",names(mmapings)[i],"*"));

  # Table caption:
  cat(paste0("Table: <a name='Tab:tree topologies for ",classif,"'/>\\label{Tab:tree topologies for ",classif,"}Various summaries concerning the topologies (no branch length) of the language family trees extracted from the ", classif, " database; the methods are constant, proportional, Grafen, nj, nnls and ga with the appropriate parameter (*k* or the distance matrix name shortened to ", paste0("'",names(mmapings),"'", " [", mmapings, "]", collapse=" ,"), "); '#' stands for 'number of...'; '$\\mu$' is the 'average of...', '$m$' is the 'minimum of...' and '$M$' is the 'maximum of...'; 'lgs' stands for the leaves (or non-internal nodes) in the language family tree which are various types of lects (most often languages); 'lvl' represent the levels in the language family tree."));
  # The table itself:
  x <- kable(do.call(rbind, lapply(summaries, function(s)
                                                    {
                                                      data.frame("Method"=s$method,
                                                                 "Param"=s$parameter,
                                                                 "no.trees"=s$summaries$no.trees.total,
                                                                 "no.leavles.tot"=sum(s$summaries$no.lgs,na.rm=TRUE),
                                                                 "avg.leaves"=sprintf("%.1f",mean(s$summaries$no.lgs,na.rm=TRUE)),
                                                                 "max.leaves"=max(s$summaries$no.lgs,na.rm=TRUE),
                                                                 "min.levels"=min(s$summaries$no.levels,na.rm=TRUE),
                                                                 "avg.levels"=sprintf("%.1f",mean(s$summaries$no.levels,na.rm=TRUE)),
                                                                 "max.levels"=max(s$summaries$no.levels,na.rm=TRUE))
                                                    })),
        format="markdown", align=c("c","c","r","r","r","r","r","r","r"), 
        col.names=c("**Method**", "**Param**", "**# trees**", "**# lgs**", "**$\\mu$ lgs**", "**$M$ lgs**", "**$m$ lvl**", "**$\\mu$ lvl**", "**$M$ lvl**"));
  print(x);
}
```

<!--- the tables for each classification -->
```{r, echo=FALSE, results='asis', message=FALSE}
suppressWarnings(.table.by.classification( classif="ethnologue" ));
```

```{r, echo=FALSE, results='asis', message=FALSE}
suppressWarnings(.table.by.classification( classif="wals" ));
```

```{r, echo=FALSE, results='asis', message=FALSE}
suppressWarnings(.table.by.classification( classif="autotyp" ));
```

```{r, echo=FALSE, results='asis', message=FALSE}
suppressWarnings(.table.by.classification( classif="glottolog" ));
```


# Appendix B: Distances between methods <a name='Appendix B'/>\label{Appendix B}

Across all classifications and methods the distances between corresponding trees are distributed as in [Figure](#Fig:tree distances) \ref{Fig:tree distances}: "PH85" varies between `r overall.dists$d.PH85$min` and `r overall.dists$d.PH85$max`, with a mean of `r overall.dists$d.PH85$mean` (and median `r overall.dists$d.PH85$median`), while "score" varies between `r overall.dists$d.score$min` and `r overall.dists$d.score$max`, with a mean of `r overall.dists$d.score$mean` (and median `r overall.dists$d.score$median`).

<!--- the distribution of overall tree distances -->
```{r, echo=FALSE, fig.cap="<a name='Fig:tree distances'/>\\label{Fig:tree distances}The distribution of distances between corresponding family trees for different pairs of methods across the whole dataset. 'PH85' (top) takes only the tree topology into account, while 'score' (bottom) also the branch lengths."}
par( mfrow=c(2,1), mar=c(4, 4, 0, 1) + 0.1 );
hist( overall.dists$d.PH85$values, main="", xlab="PH85", ylab="Counts", col=grey(0.5) );
hist( overall.dists$d.score$values, main="", xlab="score", ylab="Counts", col=grey(0.5) );
```

[Table](#Tab:distances methods for all) \ref{Tab:distances methods for all} presents the summaries (minimum, median, mean and maximum) for the "PH85" and "score" distances between the corresponding language family trees across all four classifications.
This table does not show all possible pairs of methods (the full data at the level of the language family is given in the TAB-separated file `./output/tree_comparisons_between_methods.csv`) but only the comparisons between: 

* the methods *constant*, *proportional* and *grafen*,
* "constant" versus *nj* (all distances),
* all the distances for method *nj*,
* all the distances for method *nnls*,
* all the distances for method *ga*,
* the corresponding distances between the methods *nnls*, *nj* and *ga*.


```{r, echo=FALSE, results='asis', message=FALSE}
# Produce the table row for a given pair of methods:
row.pair.methods <- function(classif="all", method1="all", const1="", dist1="", method2="all", const2="", dist2="")
{
  mmapings <- c("asjp"="asjp16", 
                "geo"="geo", 
                "w:g"="wals(gower)", "w:e"="wals(euclidean)", "w:gm"="wals(gower,mode)", "w:em"="wals(euclidean,mode)", 
                "auto"="autotyp", 
                "m:e"="mg2015(ethnologue)", "m:w"="mg2015(wals)", "m:a"="mg2015(autotyp)", "m:g"="mg2015(glottolog)");
  tmp <- summaries.tree.comparisons( classif=classif, method1=method1, const1=const1, dist1=dist1, method2=method2, const2=const2, dist2=dist2 );
  if( tmp$n != 0 )
  {
    data.frame("Method1"=paste0("**",ifelse( method1 == "constant", "const", ifelse( method1 == "proportional", "prop", method1 ) ),"**"),
               "Param1"= paste0("*",ifelse( method1 %in% c("constant","proportional"), const1, ifelse( method1 %in% c("nnls","nj","ga"), names(mmapings)[mmapings == dist1], "-" ) ),"*"),
               "Method2"=paste0("**",ifelse( method2 == "constant", "const", ifelse( method2 == "proportional", "prop", method2 ) ),"**"),
               "Param2"= paste0("*",ifelse( method2 %in% c("constant","proportional"), const2, ifelse( method2 %in% c("nnls","nj","ga"), names(mmapings)[mmapings == dist2], "-" ) ),"*"),
               "PH85.min"=tmp$d.PH85$min, "PH85.median"=tmp$d.PH85$median, "PH85.mean"=tmp$d.PH85$mean, "PH85.max"=tmp$d.PH85$max, 
               "score.min"= tmp$d.score$min, "score.median"=tmp$d.score$median, "score.mean"=tmp$d.score$mean, "score.max"=tmp$d.score$max);
  } else
  {
    NULL;
  }
}

dist.latex.table <- function( classif="all" )
{
  # Build the data.frame holding the table:
  x <- NULL;
  cases <- unique( tree.comparisons[,c("Method1","Constant1","Distance1","Method2","Constant2","Distance2")] );
  dists <- unique( tree.comparisons$Distance1 ); dists <- as.character(dists[ !is.na(dists) ]);
  
  # constant, proportional, grafen:
  x <- row.pair.methods(classif=classif, method1="constant",     const1=1, dist1="", method2="proportional", const2=1,  dist2="");
  x <- rbind(x, row.pair.methods(classif=classif, method1="constant",     const1=1, dist1="", method2="grafen",       const2="", dist2=""));
  x <- rbind(x, row.pair.methods(classif=classif, method1="proportional", const1=1, dist1="", method2="grafen",       const2="", dist2=""));
  
  # constant vs nj:
  for( i in 1:length(dists) )
  {
    x <- rbind(x, row.pair.methods(classif=classif, method1="constant", const1=1, dist1="", method2="nj", const2="",  dist2=dists[i]));
  }
  
  # nj:
  for( i in 1:(length(dists)-1) )
  {
    for( j in (i+1):length(dists) )
    {
      x <- rbind(x, row.pair.methods(classif=classif, method1="nj", const1="", dist1=dists[i], method2="nj", const2="",  dist2=dists[j]));
    }
  }
  
  # nnls:
  for( i in 1:(length(dists)-1) )
  {
    for( j in (i+1):length(dists) )
    {
      x <- rbind(x, row.pair.methods(classif=classif, method1="nnls", const1="", dist1=dists[i], method2="nnls", const2="",  dist2=dists[j]));
    }
  }

  # ga:
  for( i in 1:(length(dists)-1) )
  {
    for( j in (i+1):length(dists) )
    {
      x <- rbind(x, row.pair.methods(classif=classif, method1="ga", const1="", dist1=dists[i], method2="ga", const2="",  dist2=dists[j]));
    }
  }
  
  # nnls vs ga:
  for( i in 1:length(dists) )
  {
    x <- rbind(x, row.pair.methods(classif=classif, method1="nnls", const1="", dist1=dists[i], method2="ga", const2="",  dist2=dists[i]));
  }
  
  # nnls vs nj:
  for( i in 1:length(dists) )
  {
    x <- rbind(x, row.pair.methods(classif=classif, method1="nnls", const1="", dist1=dists[i], method2="nj", const2="",  dist2=dists[i]));
  }
  
  # ga vs nj:
  for( i in 1:length(dists) )
  {
    x <- rbind(x, row.pair.methods(classif=classif, method1="nj", const1="", dist1=dists[i], method2="ga", const2="",  dist2=dists[i]));
  }
     
  # Table caption:
  cat(paste0("Table: <a name='Tab:distances methods for ",classif,"'/>\\label{Tab:distances methods for ",classif,"}Selected pairs of methods (**Met~1~** and **Met~2~**) with their parameters (**Par~1~** and **Par~2~**) for ", ifelse( classif == "all", "all classifications", classif), ". methods *constant* and *proportional* are shortneded to 'const' and 'prop', while the distance names are shortneed as described above. As opposed to the 'PH85' (**PH**) distances, the 'score' (**sco**) comparisons involving the *geo* distance are so large due to the measurement scale (kilometers). As above, '$\\mu$' is the 'average of...', '$m$' is the 'minimum of...' and '$M$' is the 'maximum of...', with $\\tilde{m}$ being the 'median of...'"));

  # The table itself:
  y <- kable(x, format="markdown", align=c("r","r","r","r","r","r","r","r","r","r","r","r"), 
        col.names=c("**Met~1~**", "**Par~1~**", "**Met~2~**", "**Par~2~**", 
                    "**$m$ PH**", "**$\\tilde{m}$ PH**", "**$\\mu$ PH**", "**$M$ PH**",
                    "**$m$ sco**", "**$\\tilde{m}$ sco**", "**$\\mu$ sco**", "**$M$ sco**"));
  print(y);
}

dist.latex.table( classif="all" );
```


First, it can be seen that most distributions are very skewed with the median much smaller than the mean, suggesting that for the vast majority of families and classifications, the differences between methods and distances are relatively small.
Second, it must be pointed out that the "score" comparisons must be taken with care as for most methods and distances the branch lengths are relatively small, except for *geo* where they can reach tens of thousands (of kilometers). 
Third, it can be seen that the differences in topology ("PH84") are mostly small, but tend to be larger when the *nj* method is used; this is to be expected given that all methods (except *nj*) use the tree topology as given by the classification, with the small differences resulting from some leaf nodes (or subtrees) being dropped out due to missing data in the distances matrix.
To zoom in the differences in topology induced by *nj* we must look at a comparison such as *constant* (or any other method that faithfully preserves the classification-given topologies including *proportional* and *grafen*) versus *nj* using "PH85": [Table](#Tab: t-tests constant-nj) \ref{Tab: t-tests constant-nj} shows the *t*-tests of the differences between pairs of *nj* distances relative to *constant*.

```{r, echo=FALSE, results='asis', message=FALSE}
# Produce a table row with t-tests of method1 vs method2 against method0:
row.t.test.vs.const <- function(classif="all", method0="constant", const0="1", dist0="", method1="nj", const1="", dist1="asjp16", method2="nj", const2="", dist2="wals(gower)")
{
  mmapings <- c("asjp"="asjp16", 
                "geo"="geo", 
                "w:g"="wals(gower)", "w:e"="wals(euclidean)", "w:gm"="wals(gower,mode)", "w:em"="wals(euclidean,mode)", 
                "auto"="autotyp", 
                "m:e"="mg2015(ethnologue)", "m:w"="mg2015(wals)", "m:a"="mg2015(autotyp)", "m:g"="mg2015(glottolog)");
  tmp1 <- summaries.tree.comparisons( classif=classif, method1=method0, const1=const0, dist1=dist0, method2=method1, const2=const1, dist2=dist1 );
  tmp2 <- summaries.tree.comparisons( classif=classif, method1=method0, const1=const0, dist1=dist0, method2=method2, const2=const2, dist2=dist2 );
  if( tmp1$n > 0  && tmp2$n > 0 )
  {
    t12 <- t.test( tmp1$d.PH85$values, tmp2$d.PH85$values );
    bold <- ifelse(t12$p.value < 0.05,"**","");
    data.frame("Dist1"= paste0(bold,"*",ifelse( method1 %in% c("constant","proportional"), const1, ifelse( method1 %in% c("nnls","nj","ga"), names(mmapings)[mmapings == dist1], "-" ) ),"*",bold),
               "Dist2"= paste0(bold,"*",ifelse( method2 %in% c("constant","proportional"), const2, ifelse( method2 %in% c("nnls","nj","ga"), names(mmapings)[mmapings == dist2], "-" ) ),"*",bold),
               "t"=paste0(bold,sprintf("%.02f",t12$statistic),bold), 
               "df"=paste0(bold,sprintf("%.02f",t12$parameter),bold), 
               "p"=paste0(bold,sprintf("%.2g",t12$p.value),ifelse(t12$p.value < 0.001,"$^{***}$",ifelse(t12$p.value < 0.01,"$^{**}$",ifelse(t12$p.value < 0.05,"$^{*}$",""))),bold) );
  } else
  {
    NULL;
  }
}

# data:
x <- NULL;
dists <- unique( tree.comparisons$Distance1 ); dists <- as.character(dists[ !is.na(dists) ]);
for( i in 1:(length(dists)-1) )
{
  for( j in (i+1):length(dists) )
  {
    tmp <- row.t.test.vs.const(classif="all", method0="constant", const0="1", dist0="", method1="nj", const1="", dist1=dists[i], method2="nj", const2="", dist2=dists[j]);
    if( is.null(x) )
    {
      x <- tmp;
    } else
    {
      x <- rbind(x, tmp);
    }
  }
}
     
# Table caption:
cat(paste0("Table: <a name='Tab: t-tests constant-nj'/>\\label{Tab: t-tests constant-nj}Differences in the topology of the trees generated by *nj* when applied to pairs of distances relative to classification-given true topology (embodied by *constant*) across all classifications. The first two columns contain the distance matrices supplied to *nj*: for each of these the distribution of 'PH85' differences versus *constant* was computed and columns 3, 4 and 5 show the *t*-test between these distributions; a significant *p*-value means that *nj* applied to the two distance matrices produces very different topologies relative to *constant* (and **bolds** the corresponding row in the table)."));

# The table itself:
y <- kable(x, format="markdown", align=c("r","r","r","r","r"), col.names=c("**Distance~1~**", "**Distance~2~**", "***t***", "**df**", "***p***"));
print(y);
```





# References

